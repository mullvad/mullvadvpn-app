// Relay Selector service.
//
// This API is used to query which relays are selectable for a set of filters,
// and to provide information about about how to unblock discarded relays.

syntax = "proto3";
package mullvad_daemon.relay_selector;

import "management_interface.proto";

service RelaySelectorService {
  // FÃ­lter the available relays by a set of constraints. These can be
  // derived from the currents settings, or a potential future settings
  // before they are applied.
  //
  // Returns the list of matching relays. For each connection using the given
  // constraints one/a pair of these relays will be selected at random.
  // Also returns a list of non-matching relays along with the set of
  // constraints/conditions that made it unavailable.
  rpc GetMatchingRelays(Selection) returns (FilteredRelays);
}

message Selection {
  oneof selection_context {
    // Give me a relay list for regular single scenario
    EntryRelayConstraints single_relay_constraints = 1;
    // Give me a relay list for when DAITA direct only is disabled
    GeneralConstraints smart_hop_relay_constraints = 2;
    // Give me a list entry relays when multihop is enabled
    MultiHopConstraints entry_constraints = 3;
    // Give me a list exit relays when multihop is enabled
    MultiHopConstraints exit_constraints = 4;
  }
}

// Constraints that apply when selecting any relay
message GeneralConstraints {
  management_interface.LocationConstraint location = 1;
  repeated string providers = 2;
  management_interface.Ownership ownership = 3;
}

// Constraints that are only applicable to entry relays
message EntrySpecificConstraints {
  management_interface.ObfuscationSettings obfuscation_settings = 1;
  management_interface.DaitaSettings daita_settings = 2;
  optional management_interface.IpVersion ip_version = 3;
}

// All constraints that apply when selecting a relay directly connected to the user
message EntryRelayConstraints {
  GeneralConstraints general_constraints = 1;
  EntrySpecificConstraints extra_constraints = 2;
}

// Constraints for both hops in a multi-hop connection
message MultiHopConstraints {
  EntryRelayConstraints entry = 1;
  GeneralConstraints exit = 3;
}

// The result of a relay selection query, contains the list of relays matching
// a query and the list of relays that were discarded when evaluating a query
message FilteredRelays {
  // List of relays matching a query
  repeated Hostname matches = 1;
  // List of relays that were discarded when evaluating a query
  repeated DiscardedRelay discarded = 2;
}

message DiscardedRelay {
  // Hostname of the discarded relay
  Hostname hostname = 1;
  // The list of constraints that did not match the relay.
  // This can be interpreted as a list of criteria necessary
  // to unblock the relay from being selectable.
  NonMatchingConstraints non_matching_constraints = 2;
}

// A hostname that uniquely identifies a single VPN relay
message Hostname {
  // The full hostname, e.g. `se-got-wg-101`
  // This can *NOT* be a location, e.g. `se` or `se-got`
  string value = 1;
}

// Set of constraints that prevents the relay from being selected
message NonMatchingConstraints {
  // The relay is currently offline
  bool inactive = 1;
  // The relay does not reside in the given location
  bool location = 2;
  // The relay is not hosted by the given provider
  bool providers = 3; // TODO: Return which provider it needs? Can be looked up in the full relay list
  // The relay ownership does not match
  bool ownership = 4;

  // -- Entry specific constraints --

  // The relay cannot be connected to with the requested ip version
  bool ip_version = 5;
  // The relay is not DAITA enabled, which was requested
  bool daita = 6;
  // The requested anti-censorship method is not available on the relay
  bool anti_censorship = 7;
  // The relay *does*  support the requested anti-censorship method, but not with the requested port
  bool port = 8;
  // This relay is already used for the other hop (entry/exit)
  bool conflict_with_other_hop = 9;
}
