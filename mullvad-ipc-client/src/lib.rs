#[macro_use]
extern crate error_chain;

use futures::{
    stream::{self, Stream},
    sync::oneshot,
};
use jsonrpc_client_core::{Client, ClientHandle, Future};
use jsonrpc_client_ipc::IpcTransport;
use mullvad_types::{
    account::{AccountData, AccountToken},
    location::GeoIpLocation,
    relay_constraints::{RelaySettings, RelaySettingsUpdate},
    relay_list::RelayList,
    settings::{Settings, TunnelOptions},
    version::AppVersionInfo,
};
use serde::{Deserialize, Serialize};
use std::{path::Path, sync::mpsc, thread, time::Duration};
use talpid_types::{net::openvpn, tunnel::TunnelStateTransition};

pub use jsonrpc_client_core::{Error as RpcError, ErrorKind as RpcErrorKind};

error_chain! {
    errors {
        AuthenticationError {
            description("Failed to authenticate the connection with the daemon")
        }

        RpcCallError(method: String) {
            description("Failed to call RPC method")
            display("Failed to call RPC method \"{}\"", method)
        }

        RpcSubscribeError(event: String) {
            description("Failed to subscribe to RPC event")
            display("Failed to subscribe to RPC event \"{}\"", event)
        }

        StartRpcClient(address: String) {
            description("Failed to start RPC client")
            display("Failed to start RPC client to {}", address)
        }

        TokioError {
            description("Failed to setup a standalone event loop")
        }

        TransportError {
            description("Failed to setup a transport")
        }
    }
}

static NO_ARGS: [u8; 0] = [];


pub fn new_standalone_ipc_client(path: &impl AsRef<Path>) -> Result<DaemonRpcClient> {
    let path = path.as_ref().to_string_lossy().to_string();

    new_standalone_transport(path, |path| {
        IpcTransport::new(&path, &tokio::reactor::Handle::current())
            .chain_err(|| ErrorKind::TransportError)
    })
}

pub fn new_standalone_transport<
    F: Send + 'static + FnOnce(String) -> Result<T>,
    T: jsonrpc_client_core::Transport,
>(
    rpc_path: String,
    transport_func: F,
) -> Result<DaemonRpcClient> {
    let (tx, rx) = oneshot::channel();
    thread::spawn(move || match spawn_transport(rpc_path, transport_func) {
        Err(e) => tx
            .send(Err(e))
            .expect("Failed to send error back to caller"),
        Ok((client, client_handle)) => {
            tx.send(Ok(client_handle))
                .expect("Failed to send client handle");

            if let Err(e) = client.wait() {
                log::error!("JSON-RPC client failed: {}", e.description());
            }
        }
    });

    rx.wait()
        .chain_err(|| ErrorKind::TransportError)?
        .map(DaemonRpcClient::new)
}

fn spawn_transport<F: Send + FnOnce(String) -> Result<T>, T: jsonrpc_client_core::Transport>(
    address: String,
    transport_func: F,
) -> Result<(Client<T>, ClientHandle)> {
    let (client, client_handle) = transport_func(address)?.into_client();
    Ok((client, client_handle))
}

pub struct DaemonRpcClient {
    rpc_client: jsonrpc_client_core::ClientHandle,
}


impl DaemonRpcClient {
    pub fn new(rpc_client: ClientHandle) -> Self {
        DaemonRpcClient { rpc_client }
    }

    pub fn connect(&mut self) -> Result<()> {
        self.call("connect", &NO_ARGS)
    }

    pub fn disconnect(&mut self) -> Result<()> {
        self.call("disconnect", &NO_ARGS)
    }

    pub fn get_account(&mut self) -> Result<Option<AccountToken>> {
        self.call("get_account", &NO_ARGS)
    }

    pub fn get_account_data(&mut self, account: AccountToken) -> Result<AccountData> {
        self.call("get_account_data", &[account])
    }

    pub fn set_allow_lan(&mut self, allow_lan: bool) -> Result<()> {
        self.call("set_allow_lan", &[allow_lan])
    }

    pub fn set_block_when_disconnected(&mut self, block_when_disconnected: bool) -> Result<()> {
        self.call("set_block_when_disconnected", &[block_when_disconnected])
    }

    pub fn get_allow_lan(&mut self) -> Result<bool> {
        self.call("get_allow_lan", &NO_ARGS)
    }

    pub fn set_auto_connect(&mut self, auto_connect: bool) -> Result<()> {
        self.call("set_auto_connect", &[auto_connect])
    }

    pub fn get_auto_connect(&mut self) -> Result<bool> {
        self.call("get_auto_connect", &NO_ARGS)
    }

    pub fn get_current_location(&mut self) -> Result<Option<GeoIpLocation>> {
        self.call("get_current_location", &NO_ARGS)
    }

    pub fn get_current_version(&mut self) -> Result<String> {
        self.call("get_current_version", &NO_ARGS)
    }

    pub fn get_relay_locations(&mut self) -> Result<RelayList> {
        self.call("get_relay_locations", &NO_ARGS)
    }

    pub fn update_relay_locations(&mut self) -> Result<()> {
        self.call("update_relay_locations", &NO_ARGS)
    }

    pub fn get_relay_settings(&mut self) -> Result<RelaySettings> {
        self.call("get_relay_settings", &NO_ARGS)
    }

    pub fn get_state(&mut self) -> Result<TunnelStateTransition> {
        self.call("get_state", &NO_ARGS)
    }

    pub fn get_tunnel_options(&mut self) -> Result<TunnelOptions> {
        self.call("get_tunnel_options", &NO_ARGS)
    }

    pub fn get_settings(&mut self) -> Result<Settings> {
        self.call("get_settings", &NO_ARGS)
    }

    pub fn get_version_info(&mut self) -> Result<AppVersionInfo> {
        self.call("get_version_info", &NO_ARGS)
    }

    pub fn set_account(&mut self, account: Option<AccountToken>) -> Result<()> {
        self.call("set_account", &[account])
    }

    pub fn set_enable_ipv6(&mut self, enabled: bool) -> Result<()> {
        self.call("set_enable_ipv6", &[enabled])
    }

    pub fn set_wireguard_mtu(&mut self, mtu: Option<u16>) -> Result<()> {
        self.call("set_wireguard_mtu", &[mtu])
    }

    pub fn set_wireguard_fwmark(&mut self, fwmark: i32) -> Result<()> {
        self.call("set_wireguard_fwmark", &[fwmark])
    }

    pub fn set_openvpn_mssfix(&mut self, mssfix: Option<u16>) -> Result<()> {
        self.call("set_openvpn_mssfix", &[mssfix])
    }

    pub fn set_openvpn_proxy(&mut self, proxy: Option<openvpn::ProxySettings>) -> Result<()> {
        self.call("set_openvpn_proxy", &[proxy])
    }

    pub fn shutdown(&mut self) -> Result<()> {
        self.call("shutdown", &NO_ARGS)
    }

    pub fn update_relay_settings(&mut self, update: RelaySettingsUpdate) -> Result<()> {
        self.call("update_relay_settings", &[update])
    }

    pub fn call<A, O>(&mut self, method: &'static str, args: &A) -> Result<O>
    where
        A: Serialize + Send + 'static,
        O: for<'de> Deserialize<'de> + Send + 'static,
    {
        self.rpc_client
            .call_method(method, args)
            .wait()
            .chain_err(|| ErrorKind::RpcCallError(method.to_owned()))
    }

    pub fn new_state_subscribe(&mut self) -> Result<mpsc::Receiver<TunnelStateTransition>> {
        let client = self.rpc_client.clone();
        let mut current_state = self.get_state()?;
        let first_message = stream::once(Ok(current_state.clone()));

        let (tx, rx) = mpsc::channel();

        let polled = tokio_timer::wheel()
            .build()
            .interval(Duration::from_secs(1))
            .then(move |_| client.call_method("get_state", &NO_ARGS));

        thread::spawn(move || {
            let _ = first_message
                .chain(polled)
                .for_each(move |state| {
                    if state != current_state {
                        current_state = state.clone();
                        if tx.send(state).is_err() {
                            log::trace!("can't send new state to subscriber");
                            return Err(jsonrpc_client_core::ErrorKind::Shutdown.into());
                        };
                    }
                    Ok(())
                })
                .wait();
        });
        Ok(rx)
    }
}
